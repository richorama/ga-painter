/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./index.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./index.ts":
/*!******************!*\
  !*** ./index.ts ***!
  \******************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var geneticalgorithm__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! geneticalgorithm */ \"./node_modules/geneticalgorithm/index.js\");\n/* harmony import */ var geneticalgorithm__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(geneticalgorithm__WEBPACK_IMPORTED_MODULE_0__);\n\nvar Phenotype = /** @class */ (function () {\n    function Phenotype() {\n        this.values = [];\n    }\n    return Phenotype;\n}());\nvar getRandomNumber = function (limit) {\n    if (limit === void 0) { limit = 256; }\n    return Math.floor(Math.random() * limit);\n};\nvar mutationFunction = function (phenotype) {\n    var position = getRandomNumber(phenotype.values.length);\n    phenotype.values[position] = getRandomNumber();\n    return phenotype;\n};\nvar crossoverFunction = function (solutionA, solutionB) {\n    var swapPosition = getRandomNumber(solutionA.values.length);\n    var resultA = new Phenotype();\n    var resultB = new Phenotype();\n    for (var i_1 = 0; i_1 < solutionA.values.length; i_1++) {\n        var a = solutionA.values[i_1];\n        var b = solutionB.values[i_1];\n        if (i_1 < swapPosition) {\n            resultA.values.push(a);\n            resultB.values.push(b);\n        }\n        else {\n            resultA.values.push(b);\n            resultB.values.push(a);\n        }\n    }\n    return [resultA, resultB];\n};\nvar draw = function (phenotype, ctx) {\n    ctx.clearRect(0, 0, 256, 256);\n    var position = 0;\n    var nextValue = function () { return phenotype.values[position++]; };\n    while (position < phenotype.values.length) {\n        ctx.beginPath();\n        ctx.moveTo(nextValue(), nextValue());\n        ctx.lineTo(nextValue(), nextValue());\n        ctx.lineTo(nextValue(), nextValue());\n        ctx.closePath();\n        ctx.fillStyle = \"rgba(\" + nextValue() + \", \" + nextValue() + \", \" + nextValue() + \", \" + nextValue() / 255 + \")\";\n        ctx.fill();\n    }\n};\nvar fitnessFunction = function (phenotype) {\n    var canvas = document.getElementById('canvas');\n    var ctx = canvas.getContext(\"2d\");\n    draw(phenotype, ctx);\n    var score = 0;\n    var pix = ctx.getImageData(0, 0, 256, 256).data;\n    for (var i_2 = 0, n = pix.length; i_2 < n; i_2 += 4) {\n        for (var p_1 = 0; p_1 < 3; p_1++) {\n            score -= Math.abs(sourceData[i_2 + p_1] - pix[i_2 + p_1]);\n        }\n    }\n    return score;\n};\nvar triangleCount = 50;\nvar population = [];\nvar populationSize = 100;\nfor (var p = 0; p < populationSize; p++) {\n    var phenotype = new Phenotype();\n    population.push(phenotype);\n    for (var i = 0; i < triangleCount * 10; i++) {\n        phenotype.values.push(getRandomNumber());\n    }\n}\nvar config = {\n    mutationFunction: mutationFunction,\n    crossoverFunction: crossoverFunction,\n    fitnessFunction: fitnessFunction,\n    population: population,\n    populationSize: populationSize\n};\nvar ga = geneticalgorithm__WEBPACK_IMPORTED_MODULE_0___default()(config);\nvar go = function () {\n    requestAnimationFrame(function () {\n        ga.evolve();\n        console.log(ga.bestScore());\n        var best = ga.best();\n        draw(best, targetCtx);\n        go();\n    });\n};\nvar targetCtx = document.getElementById('best').getContext('2d');\nvar image = new Image();\nvar sourceData;\nimage.onload = function () {\n    var canvas = document.getElementById('target');\n    var ctx = canvas.getContext(\"2d\");\n    ctx.drawImage(image, 0, 0, 256, 256);\n    sourceData = ctx.getImageData(0, 0, 256, 256).data;\n    go();\n};\nimage.src = 'target.jpg';\n\n\n//# sourceURL=webpack:///./index.ts?");

/***/ }),

/***/ "./node_modules/geneticalgorithm/index.js":
/*!************************************************!*\
  !*** ./node_modules/geneticalgorithm/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function geneticAlgorithmConstructor(options) {\n\n    function settingDefaults() { return {\n \n        mutationFunction : function(phenotype) { return phenotype },\n \n        crossoverFunction : function(a,b) { return [a,b] },\n \n        fitnessFunction : function(phenotype) { return 0 },\n\n        doesABeatBFunction : undefined,\n \n        population : [],\n        populationSize : 100,\n    }}\n\n    function settingWithDefaults( settings , defaults ) {\n        settings = settings || {}\n\n        settings.mutationFunction = settings.mutationFunction || defaults.mutationFunction\n        settings.crossoverFunction = settings.crossoverFunction || defaults.crossoverFunction\n        settings.fitnessFunction = settings.fitnessFunction || defaults.fitnessFunction\n\n        settings.doesABeatBFunction = settings.doesABeatBFunction || defaults.doesABeatBFunction\n\n        settings.population = settings.population || defaults.population\n        if ( settings.population.length <= 0 ) throw Error(\"population must be an array and contain at least 1 phenotypes\")\n\n        settings.populationSize = settings.populationSize || defaults.populationSize\n        if ( settings.populationSize <= 0 ) throw Error(\"populationSize must be greater than 0\")\n\n        return settings\n    }\n\n    var settings = settingWithDefaults(options,settingDefaults())\n\n    function populate () {\n        var size = settings.population.length\n        while( settings.population.length < settings.populationSize ) {\n            settings.population.push(\n                mutate(\n                    cloneJSON( settings.population[ Math.floor( Math.random() * size ) ] )\n                )\n            )\n        }\n    }\n\n    function cloneJSON( object ) {\n        return JSON.parse ( JSON.stringify ( object ) )\n    }\n\n    function mutate(phenotype) {\n        return settings.mutationFunction(cloneJSON(phenotype))\n    }\n\n    function crossover(phenotype) {\n        phenotype = cloneJSON(phenotype)\n        var mate = settings.population[ Math.floor(Math.random() * settings.population.length ) ]\n        mate = cloneJSON(mate)\n        return settings.crossoverFunction(phenotype,mate)[0]\n    }\n\n    function doesABeatB(a,b) {\n        var doesABeatB = false;\n        if ( settings.doesABeatBFunction ) {\n            return settings.doesABeatBFunction(a,b)\n        } else {\n            return settings.fitnessFunction(a) >= settings.fitnessFunction(b)\n        }\n    }\n\n    function compete( ) {\n        var nextGeneration = []\n\n        for( var p = 0 ; p < settings.population.length - 1 ; p+=2 ) {\n            var phenotype = settings.population[p];\n            var competitor = settings.population[p+1];\n\n            nextGeneration.push(phenotype)\n            if ( doesABeatB( phenotype , competitor )) {\n                if ( Math.random() < 0.5 ) {\n                    nextGeneration.push(mutate(phenotype))\n                } else {\n                    nextGeneration.push(crossover(phenotype))\n                }\n            } else {\n                nextGeneration.push(competitor)\n            }\n        }\n\n        settings.population = nextGeneration;\n    }\n\n\n\n    function randomizePopulationOrder( ) {\n\n        for( var index = 0 ; index < settings.population.length ; index++ ) {\n            var otherIndex = Math.floor( Math.random() * settings.population.length )\n            var temp = settings.population[otherIndex]\n            settings.population[otherIndex] = settings.population[index]\n            settings.population[index] = temp\n        }\n    }\n\n    return {\n        evolve : function (options) {\n\n            if ( options ) { \n                settings = settingWithDefaults(options,settings)\n            }\n            \n            populate()\n            randomizePopulationOrder()\n            compete()\n            return this\n        },\n        best : function() {\n            var scored = this.scoredPopulation()\n            var result = scored.reduce(function(a,b){\n                return a.score >= b.score ? a : b\n            },scored[0]).phenotype\n            return cloneJSON(result)\n        },\n        bestScore : function() {\n            return settings.fitnessFunction( this.best() )\n        },\n        population : function() {\n            return cloneJSON( this.config().population )\n        },\n        scoredPopulation : function() {\n            return this.population().map(function(phenotype) {\n                return {\n                    phenotype : cloneJSON( phenotype ),\n                    score : settings.fitnessFunction( phenotype )\n                }\n            })\n        },\n        config : function() {\n            return cloneJSON( settings )\n        },\n        clone : function(options) {\n            return geneticAlgorithmConstructor( \n                settingWithDefaults(options, \n                    settingWithDefaults( this.config(), settings ) \n                    )\n                )\n        }\n    }\n}\n\n\n//# sourceURL=webpack:///./node_modules/geneticalgorithm/index.js?");

/***/ })

/******/ });