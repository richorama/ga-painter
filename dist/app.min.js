/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./app.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./app.ts":
/*!****************!*\
  !*** ./app.ts ***!
  \****************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _ga__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ga */ \"./ga.ts\");\n/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./common */ \"./common.ts\");\n\n\nvar getRandomNumber = function (limit) {\n    if (limit === void 0) { limit = 256; }\n    return Math.floor(Math.random() * limit);\n};\nvar mutationFunction = function (phenotype) {\n    var mutationCount = getRandomNumber(10);\n    if (getRandomNumber(5) === 1) {\n        // make a major mutation\n        var position = getRandomNumber(phenotype.values.length / 2);\n        phenotype.values[position * 2] = getRandomNumber();\n        phenotype.values[position * 2 + 1] = getRandomNumber();\n        return phenotype;\n    }\n    // try a minor adjustment\n    for (var i_1 = 0; i_1 < mutationCount; i_1++) {\n        var position = getRandomNumber(phenotype.values.length);\n        var value = phenotype.values[position];\n        value += (getRandomNumber(4) - 2);\n        phenotype.values[position] = Math.max(0, Math.min(255, value));\n    }\n    return phenotype;\n};\nvar crossoverFunction = function (solutionA, solutionB) {\n    var swapPosition = getRandomNumber(solutionA.values.length);\n    var resultA = new _common__WEBPACK_IMPORTED_MODULE_1__[\"Phenotype\"](new Uint8ClampedArray(solutionA.values.length));\n    var resultB = new _common__WEBPACK_IMPORTED_MODULE_1__[\"Phenotype\"](new Uint8ClampedArray(solutionA.values.length));\n    for (var i_2 = 0; i_2 < solutionA.values.length; i_2++) {\n        var a = solutionA.values[i_2];\n        var b = solutionB.values[i_2];\n        if (i_2 < swapPosition) {\n            resultA.values[i_2] = a;\n            resultB.values[i_2] = b;\n        }\n        else {\n            resultA.values[i_2] = b;\n            resultB.values[i_2] = a;\n        }\n    }\n    return [resultA, resultB];\n};\nvar fitnessFunction = function (population) {\n    return new Promise(function (resolve) {\n        var responses = [];\n        var responseCount = 0;\n        workerPool.forEach(function (x) { return x.onmessage = function (msg) {\n            responses[msg.data.index] = msg.data.score;\n            responseCount += 1;\n            if (responseCount === population.length)\n                resolve(responses);\n        }; });\n        population.forEach(function (data, index) {\n            workerPool[index % workerPool.length].postMessage({\n                data: data,\n                index: index,\n                fitness: true\n            });\n        });\n    });\n};\nvar controlPointCount = 200;\nvar population = [];\nvar populationSize = 100;\nfor (var p = 0; p < populationSize; p++) {\n    var phenotype = new _common__WEBPACK_IMPORTED_MODULE_1__[\"Phenotype\"](new Uint8ClampedArray(controlPointCount * 2));\n    population.push(phenotype);\n    for (var i = 0; i < controlPointCount * 2; i++) {\n        phenotype.values[i] = getRandomNumber();\n    }\n}\nvar ga = new _ga__WEBPACK_IMPORTED_MODULE_0__[\"default\"](fitnessFunction, crossoverFunction, mutationFunction, population);\nvar generations = 0;\nvar lastGenerations = 0;\nvar generationsPerSecond = 0;\nvar lastBest = Number.MIN_SAFE_INTEGER;\nsetInterval(function () {\n    generationsPerSecond = generations - lastGenerations;\n    lastGenerations = generations;\n}, 1000);\nvar go = function () {\n    ga.evolve().then(function () {\n        generations += 1;\n        var best = ga.getBestScore();\n        if (best > lastBest && ga.getBest()) {\n            Object(_common__WEBPACK_IMPORTED_MODULE_1__[\"draw\"])(ga.getBest(), targetCtx, sourceData);\n            lastBest = best;\n        }\n        document.getElementById('status').innerText = generations + \" generations (\" + generationsPerSecond + \"/sec) score = \" + best;\n        setTimeout(go, 0);\n    });\n};\nvar workerPool = [];\nvar initialiseWorkerPool = function (data) {\n    for (var i_3 = 0; i_3 < navigator.hardwareConcurrency; i_3++) {\n        var worker = new Worker('dist/worker.min.js');\n        workerPool.push(worker);\n        worker.postMessage({\n            init: true,\n            data: data\n        });\n    }\n};\nvar targetCtx = document.getElementById('best').getContext('2d', { alpha: false });\nvar image = new Image();\nvar sourceData;\nimage.onload = function () {\n    var canvas = document.getElementById('target');\n    var ctx = canvas.getContext(\"2d\", { alpha: false });\n    ctx.drawImage(image, 0, 0, 256, 256);\n    //initialiseWorkerPool(sourceData)\n    var data = ctx.getImageData(0, 0, 256, 256);\n    var output = Object(_common__WEBPACK_IMPORTED_MODULE_1__[\"calculateScoreMatrix\"])(data.data);\n    for (var i = 0; i < output.length; i++) {\n        data.data[i] = output[i];\n    }\n    var diffCtx = document.getElementById('diff').getContext('2d', { alpha: false });\n    diffCtx.putImageData(data, 0, 0);\n    //go()\n};\nimage.src = 'target.jpg';\nfunction createPoints(scoreMatrix) {\n    for (var x = 0; x < 16; x++) {\n        for (var y = 0; y < 16; y++) {\n            var index = 4 * 16 * 256 * y + 4 * 16 * x;\n        }\n    }\n}\n\n\n//# sourceURL=webpack:///./app.ts?");

/***/ }),

/***/ "./common.ts":
/*!*******************!*\
  !*** ./common.ts ***!
  \*******************/
/*! exports provided: Phenotype, draw, getRgbValues, standardDeviation, average, calculateScoreMatrix */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Phenotype\", function() { return Phenotype; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"draw\", function() { return draw; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getRgbValues\", function() { return getRgbValues; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"standardDeviation\", function() { return standardDeviation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"average\", function() { return average; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"calculateScoreMatrix\", function() { return calculateScoreMatrix; });\n/* harmony import */ var delaunator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! delaunator */ \"./node_modules/delaunator/index.js\");\n\nvar Phenotype = /** @class */ (function () {\n    function Phenotype(values) {\n        this.values = values;\n    }\n    return Phenotype;\n}());\n\nvar draw = function (phenotype, ctx, sourceData) {\n    var position = 0;\n    var values = [];\n    while (position < phenotype.values.length) {\n        values.push([phenotype.values[position++], phenotype.values[position++]]);\n    }\n    var triangles = delaunator__WEBPACK_IMPORTED_MODULE_0__[\"default\"].from(values).triangles;\n    ctx.fillStyle = \"rgb(0,0,0)\";\n    ctx.fillRect(0, 0, 256, 256);\n    for (var i = 0; i < triangles.length; i += 3) {\n        ctx.beginPath();\n        var x = 0;\n        var y = 0;\n        for (var j = 0; j < 3; j++) {\n            x += values[triangles[i + j]][0];\n            y += values[triangles[i + j]][1];\n        }\n        x = Math.floor(x / 3);\n        y = Math.floor(y / 3);\n        var sourceIndex = (4 * 256 * y) + (4 * x);\n        var r = sourceData[sourceIndex];\n        var g = sourceData[sourceIndex + 1];\n        var b = sourceData[sourceIndex + 2];\n        ctx.strokeStyle = ctx.fillStyle = \"rgb(\" + r + \", \" + g + \", \" + b + \")\";\n        ctx.moveTo(values[triangles[i]][0], values[triangles[i]][1]);\n        ctx.lineTo(values[triangles[i + 1]][0], values[triangles[i + 1]][1]);\n        ctx.lineTo(values[triangles[i + 2]][0], values[triangles[i + 2]][1]);\n        ctx.stroke();\n        ctx.fill();\n    }\n};\nvar getRgbValues = function (sourceData, x, y) {\n    return [\n        sourceData[(4 * 256 * y) + (4 * x)],\n        sourceData[(4 * 256 * y) + (4 * x) + 1],\n        sourceData[(4 * 256 * y) + (4 * x) + 2]\n    ];\n};\nvar standardDeviation = function (values) {\n    var avg = average(values);\n    var squareDiffs = values.map(function (value) {\n        var diff = value - avg;\n        return diff * diff;\n    });\n    return Math.sqrt(average(squareDiffs));\n};\nvar average = function (data) {\n    var sum = data.reduce(function (sum, value) {\n        return sum + value;\n    }, 0);\n    return sum / data.length;\n};\nvar calculateScoreMatrix = function (source) {\n    var result = [];\n    for (var i = 0; i < source.length; i++) {\n        result[i] = 1;\n    }\n    var maxVal = 0;\n    for (var x = 1; x < 255; x++) {\n        for (var y = 1; y < 255; y++) {\n            var sourceValue = getRgbValues(source, x, y);\n            var up = getRgbValues(source, x, y - 1);\n            var down = getRgbValues(source, x, y + 1);\n            var left = getRgbValues(source, x - 1, y);\n            var right = getRgbValues(source, x + 1, y);\n            var directions = [\n                up, down, left, right, sourceValue\n            ];\n            var devation = standardDeviation(directions.map(function (x) { return x[0]; }))\n                + standardDeviation(directions.map(function (x) { return x[1]; }))\n                + standardDeviation(directions.map(function (x) { return x[2]; })) + 1;\n            if (devation > maxVal)\n                maxVal = devation;\n            result[256 * 4 * y + x * 4] = devation;\n            result[256 * 4 * y + x * 4 + 1] = devation;\n            result[256 * 4 * y + x * 4 + 2] = devation;\n            result[256 * 4 * y + x * 4 + 3] = 255;\n        }\n    }\n    for (var i = 0; i < result.length; i += 4) {\n        for (var p = 0; p < 3; p++) {\n            var val = result[i + p];\n            result[i + p] = Math.floor(255.0 * val / maxVal);\n        }\n    }\n    return result;\n};\n\n\n//# sourceURL=webpack:///./common.ts?");

/***/ }),

/***/ "./ga.ts":
/*!***************!*\
  !*** ./ga.ts ***!
  \***************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (undefined && undefined.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar Ga = /** @class */ (function () {\n    function Ga(fitnessFunction, crossoverFunction, mutationFunction, seedPopulation) {\n        this.bestScore = Number.MIN_SAFE_INTEGER;\n        this.fitnessFunction = fitnessFunction;\n        this.crossoverFunction = crossoverFunction;\n        this.mutationFunction = mutationFunction;\n        this.population = seedPopulation;\n    }\n    Ga.prototype.getBest = function () {\n        return this.best;\n    };\n    Ga.prototype.getBestScore = function () {\n        return this.bestScore;\n    };\n    Ga.prototype.evolve = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var nextGeneration, fitness, maxValue, minValue, normalisedFitness, total, getByFitness, bestOfGeneration, a, b, _a, nextA, nextB;\n            var _this = this;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        nextGeneration = [];\n                        return [4 /*yield*/, this.fitnessFunction(this.population)];\n                    case 1:\n                        fitness = _b.sent();\n                        maxValue = Math.max.apply(Math, fitness);\n                        minValue = Math.min.apply(Math, fitness);\n                        if (maxValue === minValue)\n                            minValue -= 1;\n                        normalisedFitness = fitness.map(function (x) { return (x - minValue) / (maxValue - minValue); });\n                        total = normalisedFitness.reduce(function (a, b) { return a + b; }, 0);\n                        getByFitness = function (value) {\n                            var subTotal = 0;\n                            for (var i = 0; i < normalisedFitness.length; i++) {\n                                subTotal += normalisedFitness[i];\n                                if (subTotal > value)\n                                    return _this.population[i];\n                            }\n                            console.log('not found by fitness');\n                            return _this.population[0];\n                        };\n                        bestOfGeneration = this.population[fitness.indexOf(maxValue)];\n                        // always keep track of the fittest\n                        if (maxValue > this.bestScore) {\n                            this.best = bestOfGeneration;\n                            this.bestScore = maxValue;\n                        }\n                        if (this.best) {\n                            nextGeneration.push(this.mutationFunction(this.best)); // always preserve the best\n                            nextGeneration.push(this.mutationFunction(bestOfGeneration));\n                        }\n                        else {\n                            nextGeneration.push(this.mutationFunction(bestOfGeneration));\n                            nextGeneration.push(this.mutationFunction(bestOfGeneration));\n                        }\n                        while (nextGeneration.length < this.population.length) {\n                            a = getByFitness(Math.random() * total);\n                            b = getByFitness(Math.random() * total);\n                            _a = this.crossoverFunction(a, b), nextA = _a[0], nextB = _a[1];\n                            nextGeneration.push(this.mutationFunction(nextA));\n                            nextGeneration.push(this.mutationFunction(nextB));\n                        }\n                        this.population = nextGeneration;\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    return Ga;\n}());\n/* harmony default export */ __webpack_exports__[\"default\"] = (Ga);\n\n\n//# sourceURL=webpack:///./ga.ts?");

/***/ }),

/***/ "./node_modules/delaunator/index.js":
/*!******************************************!*\
  !*** ./node_modules/delaunator/index.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Delaunator; });\n\nconst EPSILON = Math.pow(2, -52);\nconst EDGE_STACK = new Uint32Array(512);\n\nclass Delaunator {\n\n    static from(points, getX = defaultGetX, getY = defaultGetY) {\n        const n = points.length;\n        const coords = new Float64Array(n * 2);\n\n        for (let i = 0; i < n; i++) {\n            const p = points[i];\n            coords[2 * i] = getX(p);\n            coords[2 * i + 1] = getY(p);\n        }\n\n        return new Delaunator(coords);\n    }\n\n    constructor(coords) {\n        const n = coords.length >> 1;\n        if (n > 0 && typeof coords[0] !== 'number') throw new Error('Expected coords to contain numbers.');\n\n        this.coords = coords;\n\n        // arrays that will store the triangulation graph\n        const maxTriangles = Math.max(2 * n - 5, 0);\n        this._triangles = new Uint32Array(maxTriangles * 3);\n        this._halfedges = new Int32Array(maxTriangles * 3);\n\n        // temporary arrays for tracking the edges of the advancing convex hull\n        this._hashSize = Math.ceil(Math.sqrt(n));\n        this._hullPrev = new Uint32Array(n); // edge to prev edge\n        this._hullNext = new Uint32Array(n); // edge to next edge\n        this._hullTri = new Uint32Array(n); // edge to adjacent triangle\n        this._hullHash = new Int32Array(this._hashSize).fill(-1); // angular edge hash\n\n        // temporary arrays for sorting points\n        this._ids = new Uint32Array(n);\n        this._dists = new Float64Array(n);\n\n        this.update();\n    }\n\n    update() {\n        const {coords, _hullPrev: hullPrev, _hullNext: hullNext, _hullTri: hullTri, _hullHash: hullHash} =  this;\n        const n = coords.length >> 1;\n\n        // populate an array of point indices; calculate input data bbox\n        let minX = Infinity;\n        let minY = Infinity;\n        let maxX = -Infinity;\n        let maxY = -Infinity;\n\n        for (let i = 0; i < n; i++) {\n            const x = coords[2 * i];\n            const y = coords[2 * i + 1];\n            if (x < minX) minX = x;\n            if (y < minY) minY = y;\n            if (x > maxX) maxX = x;\n            if (y > maxY) maxY = y;\n            this._ids[i] = i;\n        }\n        const cx = (minX + maxX) / 2;\n        const cy = (minY + maxY) / 2;\n\n        let minDist = Infinity;\n        let i0, i1, i2;\n\n        // pick a seed point close to the center\n        for (let i = 0; i < n; i++) {\n            const d = dist(cx, cy, coords[2 * i], coords[2 * i + 1]);\n            if (d < minDist) {\n                i0 = i;\n                minDist = d;\n            }\n        }\n        const i0x = coords[2 * i0];\n        const i0y = coords[2 * i0 + 1];\n\n        minDist = Infinity;\n\n        // find the point closest to the seed\n        for (let i = 0; i < n; i++) {\n            if (i === i0) continue;\n            const d = dist(i0x, i0y, coords[2 * i], coords[2 * i + 1]);\n            if (d < minDist && d > 0) {\n                i1 = i;\n                minDist = d;\n            }\n        }\n        let i1x = coords[2 * i1];\n        let i1y = coords[2 * i1 + 1];\n\n        let minRadius = Infinity;\n\n        // find the third point which forms the smallest circumcircle with the first two\n        for (let i = 0; i < n; i++) {\n            if (i === i0 || i === i1) continue;\n            const r = circumradius(i0x, i0y, i1x, i1y, coords[2 * i], coords[2 * i + 1]);\n            if (r < minRadius) {\n                i2 = i;\n                minRadius = r;\n            }\n        }\n        let i2x = coords[2 * i2];\n        let i2y = coords[2 * i2 + 1];\n\n        if (minRadius === Infinity) {\n            // order collinear points by dx (or dy if all x are identical)\n            // and return the list as a hull\n            for (let i = 0; i < n; i++) {\n                this._dists[i] = (coords[2 * i] - coords[0]) || (coords[2 * i + 1] - coords[1]);\n            }\n            quicksort(this._ids, this._dists, 0, n - 1);\n            const hull = new Uint32Array(n);\n            let j = 0;\n            for (let i = 0, d0 = -Infinity; i < n; i++) {\n                const id = this._ids[i];\n                if (this._dists[id] > d0) {\n                    hull[j++] = id;\n                    d0 = this._dists[id];\n                }\n            }\n            this.hull = hull.subarray(0, j);\n            this.triangles = new Uint32Array(0);\n            this.halfedges = new Uint32Array(0);\n            return;\n        }\n\n        // swap the order of the seed points for counter-clockwise orientation\n        if (orient(i0x, i0y, i1x, i1y, i2x, i2y)) {\n            const i = i1;\n            const x = i1x;\n            const y = i1y;\n            i1 = i2;\n            i1x = i2x;\n            i1y = i2y;\n            i2 = i;\n            i2x = x;\n            i2y = y;\n        }\n\n        const center = circumcenter(i0x, i0y, i1x, i1y, i2x, i2y);\n        this._cx = center.x;\n        this._cy = center.y;\n\n        for (let i = 0; i < n; i++) {\n            this._dists[i] = dist(coords[2 * i], coords[2 * i + 1], center.x, center.y);\n        }\n\n        // sort the points by distance from the seed triangle circumcenter\n        quicksort(this._ids, this._dists, 0, n - 1);\n\n        // set up the seed triangle as the starting hull\n        this._hullStart = i0;\n        let hullSize = 3;\n\n        hullNext[i0] = hullPrev[i2] = i1;\n        hullNext[i1] = hullPrev[i0] = i2;\n        hullNext[i2] = hullPrev[i1] = i0;\n\n        hullTri[i0] = 0;\n        hullTri[i1] = 1;\n        hullTri[i2] = 2;\n\n        hullHash.fill(-1);\n        hullHash[this._hashKey(i0x, i0y)] = i0;\n        hullHash[this._hashKey(i1x, i1y)] = i1;\n        hullHash[this._hashKey(i2x, i2y)] = i2;\n\n        this.trianglesLen = 0;\n        this._addTriangle(i0, i1, i2, -1, -1, -1);\n\n        for (let k = 0, xp, yp; k < this._ids.length; k++) {\n            const i = this._ids[k];\n            const x = coords[2 * i];\n            const y = coords[2 * i + 1];\n\n            // skip near-duplicate points\n            if (k > 0 && Math.abs(x - xp) <= EPSILON && Math.abs(y - yp) <= EPSILON) continue;\n            xp = x;\n            yp = y;\n\n            // skip seed triangle points\n            if (i === i0 || i === i1 || i === i2) continue;\n\n            // find a visible edge on the convex hull using edge hash\n            let start = 0;\n            for (let j = 0, key = this._hashKey(x, y); j < this._hashSize; j++) {\n                start = hullHash[(key + j) % this._hashSize];\n                if (start !== -1 && start !== hullNext[start]) break;\n            }\n\n            start = hullPrev[start];\n            let e = start, q;\n            while (q = hullNext[e], !orient(x, y, coords[2 * e], coords[2 * e + 1], coords[2 * q], coords[2 * q + 1])) {\n                e = q;\n                if (e === start) {\n                    e = -1;\n                    break;\n                }\n            }\n            if (e === -1) continue; // likely a near-duplicate point; skip it\n\n            // add the first triangle from the point\n            let t = this._addTriangle(e, i, hullNext[e], -1, -1, hullTri[e]);\n\n            // recursively flip triangles from the point until they satisfy the Delaunay condition\n            hullTri[i] = this._legalize(t + 2);\n            hullTri[e] = t; // keep track of boundary triangles on the hull\n            hullSize++;\n\n            // walk forward through the hull, adding more triangles and flipping recursively\n            let n = hullNext[e];\n            while (q = hullNext[n], orient(x, y, coords[2 * n], coords[2 * n + 1], coords[2 * q], coords[2 * q + 1])) {\n                t = this._addTriangle(n, i, q, hullTri[i], -1, hullTri[n]);\n                hullTri[i] = this._legalize(t + 2);\n                hullNext[n] = n; // mark as removed\n                hullSize--;\n                n = q;\n            }\n\n            // walk backward from the other side, adding more triangles and flipping\n            if (e === start) {\n                while (q = hullPrev[e], orient(x, y, coords[2 * q], coords[2 * q + 1], coords[2 * e], coords[2 * e + 1])) {\n                    t = this._addTriangle(q, i, e, -1, hullTri[e], hullTri[q]);\n                    this._legalize(t + 2);\n                    hullTri[q] = t;\n                    hullNext[e] = e; // mark as removed\n                    hullSize--;\n                    e = q;\n                }\n            }\n\n            // update the hull indices\n            this._hullStart = hullPrev[i] = e;\n            hullNext[e] = hullPrev[n] = i;\n            hullNext[i] = n;\n\n            // save the two new edges in the hash table\n            hullHash[this._hashKey(x, y)] = i;\n            hullHash[this._hashKey(coords[2 * e], coords[2 * e + 1])] = e;\n        }\n\n        this.hull = new Uint32Array(hullSize);\n        for (let i = 0, e = this._hullStart; i < hullSize; i++) {\n            this.hull[i] = e;\n            e = hullNext[e];\n        }\n\n        // trim typed triangle mesh arrays\n        this.triangles = this._triangles.subarray(0, this.trianglesLen);\n        this.halfedges = this._halfedges.subarray(0, this.trianglesLen);\n    }\n\n    _hashKey(x, y) {\n        return Math.floor(pseudoAngle(x - this._cx, y - this._cy) * this._hashSize) % this._hashSize;\n    }\n\n    _legalize(a) {\n        const {_triangles: triangles, _halfedges: halfedges, coords} = this;\n\n        let i = 0;\n        let ar = 0;\n\n        // recursion eliminated with a fixed-size stack\n        while (true) {\n            const b = halfedges[a];\n\n            /* if the pair of triangles doesn't satisfy the Delaunay condition\n             * (p1 is inside the circumcircle of [p0, pl, pr]), flip them,\n             * then do the same check/flip recursively for the new pair of triangles\n             *\n             *           pl                    pl\n             *          /||\\                  /  \\\n             *       al/ || \\bl            al/    \\a\n             *        /  ||  \\              /      \\\n             *       /  a||b  \\    flip    /___ar___\\\n             *     p0\\   ||   /p1   =>   p0\\---bl---/p1\n             *        \\  ||  /              \\      /\n             *       ar\\ || /br             b\\    /br\n             *          \\||/                  \\  /\n             *           pr                    pr\n             */\n            const a0 = a - a % 3;\n            ar = a0 + (a + 2) % 3;\n\n            if (b === -1) { // convex hull edge\n                if (i === 0) break;\n                a = EDGE_STACK[--i];\n                continue;\n            }\n\n            const b0 = b - b % 3;\n            const al = a0 + (a + 1) % 3;\n            const bl = b0 + (b + 2) % 3;\n\n            const p0 = triangles[ar];\n            const pr = triangles[a];\n            const pl = triangles[al];\n            const p1 = triangles[bl];\n\n            const illegal = inCircle(\n                coords[2 * p0], coords[2 * p0 + 1],\n                coords[2 * pr], coords[2 * pr + 1],\n                coords[2 * pl], coords[2 * pl + 1],\n                coords[2 * p1], coords[2 * p1 + 1]);\n\n            if (illegal) {\n                triangles[a] = p1;\n                triangles[b] = p0;\n\n                const hbl = halfedges[bl];\n\n                // edge swapped on the other side of the hull (rare); fix the halfedge reference\n                if (hbl === -1) {\n                    let e = this._hullStart;\n                    do {\n                        if (this._hullTri[e] === bl) {\n                            this._hullTri[e] = a;\n                            break;\n                        }\n                        e = this._hullPrev[e];\n                    } while (e !== this._hullStart);\n                }\n                this._link(a, hbl);\n                this._link(b, halfedges[ar]);\n                this._link(ar, bl);\n\n                const br = b0 + (b + 1) % 3;\n\n                // don't worry about hitting the cap: it can only happen on extremely degenerate input\n                if (i < EDGE_STACK.length) {\n                    EDGE_STACK[i++] = br;\n                }\n            } else {\n                if (i === 0) break;\n                a = EDGE_STACK[--i];\n            }\n        }\n\n        return ar;\n    }\n\n    _link(a, b) {\n        this._halfedges[a] = b;\n        if (b !== -1) this._halfedges[b] = a;\n    }\n\n    // add a new triangle given vertex indices and adjacent half-edge ids\n    _addTriangle(i0, i1, i2, a, b, c) {\n        const t = this.trianglesLen;\n\n        this._triangles[t] = i0;\n        this._triangles[t + 1] = i1;\n        this._triangles[t + 2] = i2;\n\n        this._link(t, a);\n        this._link(t + 1, b);\n        this._link(t + 2, c);\n\n        this.trianglesLen += 3;\n\n        return t;\n    }\n}\n\n// monotonically increases with real angle, but doesn't need expensive trigonometry\nfunction pseudoAngle(dx, dy) {\n    const p = dx / (Math.abs(dx) + Math.abs(dy));\n    return (dy > 0 ? 3 - p : 1 + p) / 4; // [0..1]\n}\n\nfunction dist(ax, ay, bx, by) {\n    const dx = ax - bx;\n    const dy = ay - by;\n    return dx * dx + dy * dy;\n}\n\n// return 2d orientation sign if we're confident in it through J. Shewchuk's error bound check\nfunction orientIfSure(px, py, rx, ry, qx, qy) {\n    const l = (ry - py) * (qx - px);\n    const r = (rx - px) * (qy - py);\n    return Math.abs(l - r) >= 3.3306690738754716e-16 * Math.abs(l + r) ? l - r : 0;\n}\n\n// a more robust orientation test that's stable in a given triangle (to fix robustness issues)\nfunction orient(rx, ry, qx, qy, px, py) {\n    const sign = orientIfSure(px, py, rx, ry, qx, qy) ||\n    orientIfSure(rx, ry, qx, qy, px, py) ||\n    orientIfSure(qx, qy, px, py, rx, ry);\n    return sign < 0;\n}\n\nfunction inCircle(ax, ay, bx, by, cx, cy, px, py) {\n    const dx = ax - px;\n    const dy = ay - py;\n    const ex = bx - px;\n    const ey = by - py;\n    const fx = cx - px;\n    const fy = cy - py;\n\n    const ap = dx * dx + dy * dy;\n    const bp = ex * ex + ey * ey;\n    const cp = fx * fx + fy * fy;\n\n    return dx * (ey * cp - bp * fy) -\n           dy * (ex * cp - bp * fx) +\n           ap * (ex * fy - ey * fx) < 0;\n}\n\nfunction circumradius(ax, ay, bx, by, cx, cy) {\n    const dx = bx - ax;\n    const dy = by - ay;\n    const ex = cx - ax;\n    const ey = cy - ay;\n\n    const bl = dx * dx + dy * dy;\n    const cl = ex * ex + ey * ey;\n    const d = 0.5 / (dx * ey - dy * ex);\n\n    const x = (ey * bl - dy * cl) * d;\n    const y = (dx * cl - ex * bl) * d;\n\n    return x * x + y * y;\n}\n\nfunction circumcenter(ax, ay, bx, by, cx, cy) {\n    const dx = bx - ax;\n    const dy = by - ay;\n    const ex = cx - ax;\n    const ey = cy - ay;\n\n    const bl = dx * dx + dy * dy;\n    const cl = ex * ex + ey * ey;\n    const d = 0.5 / (dx * ey - dy * ex);\n\n    const x = ax + (ey * bl - dy * cl) * d;\n    const y = ay + (dx * cl - ex * bl) * d;\n\n    return {x, y};\n}\n\nfunction quicksort(ids, dists, left, right) {\n    if (right - left <= 20) {\n        for (let i = left + 1; i <= right; i++) {\n            const temp = ids[i];\n            const tempDist = dists[temp];\n            let j = i - 1;\n            while (j >= left && dists[ids[j]] > tempDist) ids[j + 1] = ids[j--];\n            ids[j + 1] = temp;\n        }\n    } else {\n        const median = (left + right) >> 1;\n        let i = left + 1;\n        let j = right;\n        swap(ids, median, i);\n        if (dists[ids[left]] > dists[ids[right]]) swap(ids, left, right);\n        if (dists[ids[i]] > dists[ids[right]]) swap(ids, i, right);\n        if (dists[ids[left]] > dists[ids[i]]) swap(ids, left, i);\n\n        const temp = ids[i];\n        const tempDist = dists[temp];\n        while (true) {\n            do i++; while (dists[ids[i]] < tempDist);\n            do j--; while (dists[ids[j]] > tempDist);\n            if (j < i) break;\n            swap(ids, i, j);\n        }\n        ids[left + 1] = ids[j];\n        ids[j] = temp;\n\n        if (right - i + 1 >= j - left) {\n            quicksort(ids, dists, i, right);\n            quicksort(ids, dists, left, j - 1);\n        } else {\n            quicksort(ids, dists, left, j - 1);\n            quicksort(ids, dists, i, right);\n        }\n    }\n}\n\nfunction swap(arr, i, j) {\n    const tmp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = tmp;\n}\n\nfunction defaultGetX(p) {\n    return p[0];\n}\nfunction defaultGetY(p) {\n    return p[1];\n}\n\n\n//# sourceURL=webpack:///./node_modules/delaunator/index.js?");

/***/ })

/******/ });