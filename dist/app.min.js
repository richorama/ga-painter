/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./app.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./app.ts":
/*!****************!*\
  !*** ./app.ts ***!
  \****************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _ga__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ga */ \"./ga.js\");\n/* harmony import */ var _ga__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_ga__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _models__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./models */ \"./models.ts\");\n\n\nvar getRandomNumber = function (limit) {\n    if (limit === void 0) { limit = 256; }\n    return Math.floor(Math.random() * limit);\n};\nvar mutationFunction = function (phenotype) {\n    var mutationCount = getRandomNumber(10);\n    if (getRandomNumber(5) === 1) {\n        // make a major mutation\n        for (var i_1 = 0; i_1 < mutationCount; i_1++) {\n            var position = getRandomNumber(phenotype.values.length);\n            phenotype.values[position] = getRandomNumber();\n        }\n        return phenotype;\n    }\n    // try a minor adjustment\n    for (var i_2 = 0; i_2 < mutationCount; i_2++) {\n        var position = getRandomNumber(phenotype.values.length);\n        var value = phenotype.values[position];\n        value += (getRandomNumber(4) - 2);\n        phenotype.values[position] = Math.max(0, Math.min(255, value));\n    }\n    return phenotype;\n};\nvar crossoverFunction = function (solutionA, solutionB) {\n    var swapPosition = getRandomNumber(solutionA.values.length);\n    var resultA = new _models__WEBPACK_IMPORTED_MODULE_1__[\"Phenotype\"]();\n    var resultB = new _models__WEBPACK_IMPORTED_MODULE_1__[\"Phenotype\"]();\n    for (var i_3 = 0; i_3 < solutionA.values.length; i_3++) {\n        var a = solutionA.values[i_3];\n        var b = solutionB.values[i_3];\n        if (i_3 < swapPosition) {\n            resultA.values.push(a);\n            resultB.values.push(b);\n        }\n        else {\n            resultA.values.push(b);\n            resultB.values.push(a);\n        }\n    }\n    return [resultA, resultB];\n};\nvar fitnessFunction = function (population) {\n    return new Promise(function (resolve, reject) {\n        var responses = [];\n        var responseCount = 0;\n        workerPool.forEach(function (x) { return x.onmessage = function (msg) {\n            responses[msg.data.index] = msg.data.score;\n            responseCount += 1;\n            if (responseCount === population.length)\n                resolve(responses);\n        }; });\n        population.forEach(function (data, index) {\n            workerPool[index % workerPool.length].postMessage({\n                data: data,\n                index: index,\n                fitness: true\n            });\n        });\n    });\n};\nvar triangleCount = 50;\nvar population = [];\nvar populationSize = 100;\nfor (var p = 0; p < populationSize; p++) {\n    var phenotype = new _models__WEBPACK_IMPORTED_MODULE_1__[\"Phenotype\"]();\n    population.push(phenotype);\n    for (var i = 0; i < triangleCount * 10; i++) {\n        phenotype.values.push(getRandomNumber());\n    }\n}\nvar config = {\n    mutationFunction: mutationFunction,\n    crossoverFunction: crossoverFunction,\n    fitnessFunction: fitnessFunction,\n    population: population,\n    populationSize: populationSize\n};\nvar ga = _ga__WEBPACK_IMPORTED_MODULE_0___default()(config);\nvar generations = 0;\nvar lastGenerations = 0;\nvar generationsPerSecond = 0;\nvar lastBest = 0;\nsetInterval(function () {\n    generationsPerSecond = generations - lastGenerations;\n    lastGenerations = generations;\n}, 1000);\nvar go = function () {\n    ga.evolve().then(function () {\n        generations += 1;\n        var best = ga.best();\n        if (best !== lastBest) {\n            Object(_models__WEBPACK_IMPORTED_MODULE_1__[\"draw\"])(best, targetCtx);\n            lastBest = best;\n        }\n        document.getElementById('status').innerText = generations + \" generations (\" + generationsPerSecond + \"/sec) score = \" + ga.bestScore();\n        setTimeout(go, 0);\n    });\n};\nvar workerPool = [];\nvar initialiseWorkerPool = function (data) {\n    for (var i_4 = 0; i_4 < navigator.hardwareConcurrency; i_4++) {\n        var worker = new Worker('dist/worker.min.js');\n        workerPool.push(worker);\n        worker.postMessage({\n            init: true,\n            data: data\n        });\n    }\n};\nvar targetCtx = document.getElementById('best').getContext('2d');\nvar image = new Image();\nvar sourceData;\nimage.onload = function () {\n    var canvas = document.getElementById('target');\n    var ctx = canvas.getContext(\"2d\");\n    ctx.drawImage(image, 0, 0, 256, 256);\n    sourceData = ctx.getImageData(0, 0, 256, 256).data;\n    initialiseWorkerPool(sourceData);\n    go();\n};\nimage.src = 'target.jpg';\n\n\n//# sourceURL=webpack:///./app.ts?");

/***/ }),

/***/ "./ga.js":
/*!***************!*\
  !*** ./ga.js ***!
  \***************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function geneticAlgorithmConstructor(options) {\n\n    let values = {}\n    function settingDefaults() {\n        return {\n            mutationFunction: function (phenotype) { return phenotype },\n            crossoverFunction: function (a, b) { return [a, b] },\n            fitnessFunction: function (phenotype) { return 0 },\n            population: [],\n            populationSize: 100,\n        }\n    }\n\n    function settingWithDefaults(settings, defaults) {\n        settings = settings || {}\n\n        settings.mutationFunction = settings.mutationFunction || defaults.mutationFunction\n        settings.crossoverFunction = settings.crossoverFunction || defaults.crossoverFunction\n        settings.fitnessFunction = settings.fitnessFunction || defaults.fitnessFunction\n\n        settings.population = settings.population || defaults.population\n        if (settings.population.length <= 0) throw Error(\"population must be an array and contain at least 1 phenotypes\")\n\n        settings.populationSize = settings.populationSize || defaults.populationSize\n        if (settings.populationSize <= 0) throw Error(\"populationSize must be greater than 0\")\n\n        return settings\n    }\n\n    var settings = settingWithDefaults(options, settingDefaults())\n\n    function cloneJSON(object) {\n        return JSON.parse(JSON.stringify(object))\n    }\n\n    async function compete() {\n        var nextGeneration = []\n\n        const fitness = await settings.fitnessFunction(settings.population)\n        const maxValue = Math.max(...fitness)\n        let minValue = Math.min(...fitness)\n        if (maxValue === minValue) minValue -= 1\n        const normalisedFitness = fitness.map(x => (x - minValue) / (maxValue - minValue))\n        const total = normalisedFitness.reduce((a, b) => a + b, 0)\n\n        const getByFitness = value => {\n            let subTotal = 0\n            for (var i = 0; i < normalisedFitness.length; i++) {\n                subTotal += normalisedFitness[i]\n                if (subTotal > value) return settings.population[i]\n            }\n            console.log('not found by fitness')\n            return settings.population[0]\n        }\n\n        // always keep the fittest\n        const fittest = settings.population[fitness.indexOf(maxValue)]\n        values.best = fittest\n        values.bestScore = maxValue\n        if (fittest) {\n            nextGeneration.push(fittest)\n            nextGeneration.push(fittest)\n        }\n        if (!fittest) console.log('fittest is null')\n        while (nextGeneration.length < settings.population.length) {\n            const a = getByFitness(Math.random() * total)\n            const b = getByFitness(Math.random() * total)\n            const [nextA, nextB] = settings.crossoverFunction(a, b)\n\n            nextGeneration.push(settings.mutationFunction(nextA))\n            nextGeneration.push(settings.mutationFunction(nextB))\n        }\n\n        settings.population = nextGeneration;\n    }\n\n\n\n    function randomizePopulationOrder() {\n\n        for (var index = 0; index < settings.population.length; index++) {\n            var otherIndex = Math.floor(Math.random() * settings.population.length)\n            var temp = settings.population[otherIndex]\n            settings.population[otherIndex] = settings.population[index]\n            settings.population[index] = temp\n        }\n    }\n\n    return {\n        evolve: async function (options) {\n\n            if (options) {\n                settings = settingWithDefaults(options, settings)\n            }\n\n            //populate()\n            //randomizePopulationOrder()\n            await compete()\n            return this\n        },\n        best: function () {\n            return values.best\n        },\n        bestScore: function () {\n            return values.bestScore\n        },\n        population: function () {\n            return cloneJSON(this.config().population)\n        },\n        scoredPopulation: function () {\n            return this.population().map(function (phenotype) {\n                return {\n                    phenotype: cloneJSON(phenotype),\n                    score: settings.fitnessFunction(phenotype)\n                }\n            })\n        },\n        config: function () {\n            return cloneJSON(settings)\n        },\n        clone: function (options) {\n            return geneticAlgorithmConstructor(\n                settingWithDefaults(options,\n                    settingWithDefaults(this.config(), settings)\n                )\n            )\n        }\n    }\n}\n\n\n//# sourceURL=webpack:///./ga.js?");

/***/ }),

/***/ "./models.ts":
/*!*******************!*\
  !*** ./models.ts ***!
  \*******************/
/*! exports provided: Phenotype, draw */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Phenotype\", function() { return Phenotype; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"draw\", function() { return draw; });\nvar Phenotype = /** @class */ (function () {\n    function Phenotype() {\n        this.values = [];\n    }\n    return Phenotype;\n}());\n\nvar draw = function (phenotype, ctx) {\n    ctx.fillStyle = \"rgb(0,0,0)\";\n    ctx.fillRect(0, 0, 256, 256);\n    var position = 0;\n    var nextValue = function () { return phenotype.values[position++]; };\n    while (position < phenotype.values.length) {\n        ctx.beginPath();\n        ctx.moveTo(nextValue(), nextValue());\n        ctx.lineTo(nextValue(), nextValue());\n        ctx.lineTo(nextValue(), nextValue());\n        ctx.closePath();\n        ctx.fillStyle = \"rgba(\" + nextValue() + \", \" + nextValue() + \", \" + nextValue() + \", \" + nextValue() / 255 + \")\";\n        ctx.fill();\n    }\n};\n\n\n//# sourceURL=webpack:///./models.ts?");

/***/ })

/******/ });